\section{Описание}

Результатом лабораторной работы является отчёт, состоящий из:
\begin{enumerate}
\item{Дневника выплонения работы, в котором отражено что и когда делалось, }
\item{Какие средства использовались и какие результаты были достигнуты на каждом шаге выполнения лабораторной работы. }
\item{Выводов о найденных недочётах. }
\item{Сравнение работы исправленной программы с предыдущей версией. }
\item{Общих выводов о выполнении лабораторной работы, полученном опыте. }
\end{enumerate}
%\pagebreak


\section{Дневник выполнения работы}

Основные этапы написания кода:
\begin{enumerate}
\item Реализация первоначальной идеи 
\item Выявление ошибок работы программы ( как логическая структура, так и работа с памятью )
\item Тестирование программы на корректность работы
\item Тест производительности программы, выявление медленно работающих функций
\item Оптимизация
\end{enumerate}

\section{Используемые средства}

\subsection{GDB}

В процессе работы над программой приходилось очень часто обращаться к  дебагеру gdb. Несмотря на его изначально "пугающий" консольный вид, новичку разобраться в нем достаточно просто. Многие ошибки и баги было невозможно отследить просто пристольно прочитывая код и прокручивая ситуации у себя в голове, тут  приходил на помощь gdb.
Для начала нужно скомпилировать программу с ключом -g, чтобы программа собралась с отладочными символами.

Основные команды для работы: break, s (step), n (next), c (continue), backtrace и др. 

Благодаря использованию gdb я существенно сократил время отладки и разработки программы. Его потенциал очень большой (GDB User Manual занимает более 700 страниц), так что теперь я всем советую пользоваться программой.

\subsection{Valgrind}

Valgrind - это необходимый инструмент для отслеживания утечек памяти в программах. Сразу приведу несколько примеров, где он меня спасал. 

Например, я непавильно обработал границы строки, и когда пропустил программу через эту утилиту, она мне быстро и точно показала, что я неправильно работаю со строкой.

\begin{lstlisting}[language=C]
 Node(char *key, unsigned long long value){
            int i = 0;
            if(key != nullptr){
                int len_key = 0;
                len_key = strlen(key);
                m_key = (char*)malloc((len_key+1) * sizeof(char));
                for(i = 0; i < len_key; i++){
                    m_key[i] = key[i];
                }
            }
            m_key[i] = '\0'; // valgrind lenkey+1        
            m_value = value;
            color = RED;
        };
\end{lstlisting}

Или другой пример. Здесь я случайно использовал функцию free() два раза на одной и той же памяти.

\begin{lstlisting}[language=C]
~Node(){
            free(m_key); // valgrind  1- to free, 2 - in deletehidden

        };
\end{lstlisting}

Valgring умеет находить утечки памяти, может найти недопустимое использование указателя, использование неинициализированных переменных и еще много неприятных моментов. Это одна из самых мощных утилит профилирования программ, которые мне встречались. Также в ее состав входят другие программы (massif - анализ выделения памяти различными частями программы, callgrind - анализ вызова функций, построение дерева функций)

\subsection{gprof}

Ну а без gprof ни одна моя программа не прошла бы checker.
Чтобы gprof заработал, необходимо скомпилировать программу с ключом -pg, а затем запустить программу без gprof. Будет создан двоичный файл gmon.out. и теперь можно запустить программу через gprof. Полученный текстовый файл profile вполне читаемый — видно, где и сколько времени проводила программа. 

\begin{center}
\begin{table}[h]

\label{tabular:times}
\begin{tabular}{c|c|c|c|c|c|c}

time  & seconds &  seconds  &  calls  & us/call & us/call & name   \\
 
  
 60.05  &    0.03 &    0.03  &   5061  &   5.93  &   5.93 & $Node::Node(char*, unsigned long long)$ \\
 20.02  &    0.04 &    0.01  &   4939  &   2.03  &   2.03 & $TRBTree::Find(char*, bool*)$ \\
 20.02   &   0.05 &    0.01  &         &         &        & $GetKey(char*)$ \\
  0.00   &   0.05 &    0.00  &   5061  &   0.00  &   0.00 & $TRBTree::FixInsertRBTree(Node*)$  \\
  0.00   &   0.05 &    0.00  &   5061  &   0.00  &   5.93 & $TRBTree::Insert_kv(char*, unsigned long long)$ \\
  0.00   &   0.05 &    0.00  &   4939  &   0.00  &   2.03 & $TRBTree::Delete_k(char*)$ \\
  0.00   &   0.05 &    0.00  &   1491  &   0.00  &   0.00 & $TRBTree::RotateLeft(Node*)$ \\
  0.00   &   0.05 &    0.00  &   1490  &   0.00  &   0.00 & $TRBTree::RotateRight(Node*)$ \\

\end{tabular}
\end{table}
\end{center}
А также граф передачи управления

\begin{lstlisting}[language=C]
 Call graph (explanation follows)


granularity: each sample hit covers 2 byte(s) for 19.98% of 0.05 seconds

index % time    self  children    called     name
                                                 <spontaneous>
[1]     80.0    0.00    0.04                 main [1]
                0.00    0.03    5061/5061        TRBTree::Insert_kv(char*, unsigned long long) [3]
                0.00    0.01    4939/4939        TRBTree::Delete_k(char*) [5]
-----------------------------------------------
                0.03    0.00    5061/5061        TRBTree::Insert_kv(char*, unsigned long long) [3]
[2]     60.0    0.03    0.00    5061         Node::Node(char*, unsigned long long) [2]
-----------------------------------------------
                0.00    0.03    5061/5061        main [1]
[3]     60.0    0.00    0.03    5061         TRBTree::Insert_kv(char*, unsigned long long) [3]
                0.03    0.00    5061/5061        Node::Node(char*, unsigned long long) [2]
                0.00    0.00    5061/5061        TRBTree::FixInsertRBTree(Node*) [13]
-----------------------------------------------
\end{lstlisting}

С помощью этой утилиты я убрал ненужные метоты get и set, которые в нашем случае только загромождали код, и вместо них напрямую обращался к данным. Также в 5 лабораторной понял, что формирование строки "на лету" при обходе дерева - неудачный вариант - программа тратит слишком много времени, вместо этого я решил сохранять путь в deque. 
\pagebreak

